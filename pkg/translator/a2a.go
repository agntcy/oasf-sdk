// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

package translator

import (
	"errors"
	"time"

	"google.golang.org/protobuf/types/known/structpb"
)

// RecordToA2A translates a record into an A2A card structure.
// Supports OASF versions 0.7.0, 0.8.0, and 1.0.0.
// Returns the A2A card data as a structpb.Struct, preserving all fields
// from the A2A protocol definition to prevent schema drift.
func RecordToA2A(record *structpb.Struct) (*structpb.Struct, error) {
	// Get A2A module - try 0.8.0/1.0.0 name first, then fall back to 0.7.0 for backward compatibility
	found, a2aModule := getModuleDataFromRecord(record, A2AModuleName) // "integration/a2a" (0.8.0, 1.0.0)
	if !found {
		found, a2aModule = getModuleDataFromRecord(record, "runtime/a2a") // 0.7.0 compatibility
	}

	if !found {
		return nil, errors.New("A2A module not found in record")
	}

	if cardDataVal, ok := a2aModule.GetFields()["card_data"]; ok {
		cardData := cardDataVal.GetStructValue()
		if cardData != nil && len(cardData.GetFields()) > 0 {
			return cardData, nil
		}
	}

	// Fallback: return the module data directly (for records where card data is at the top level)
	// This handles older schema versions where card data might be at the top level
	return a2aModule, nil
}

// A2AToRecord translates an A2A card data back into an OASF-compliant record format.
// Generates records using the targetSchema (1.0.0-rc.1) with simplified A2A module structure.
// Accepts both wrapped format ({"a2aCard": {...}}) and unwrapped format (direct card object).
func A2AToRecord(a2aData *structpb.Struct) (*structpb.Struct, error) { //nolint:cyclop
	// Extract the a2aCard from the input data - handle both wrapped and unwrapped formats
	var A2ACardStruct *structpb.Struct

	if a2aCardVal, ok := a2aData.GetFields()["a2aCard"]; ok {
		// Wrapped format: {"a2aCard": {...}}
		A2ACardStruct = a2aCardVal.GetStructValue()
		if A2ACardStruct == nil {
			return nil, errors.New("'a2aCard' is not a struct")
		}
	} else {
		// Unwrapped format: direct card object
		A2ACardStruct = a2aData
	}

	// Convert A2A card struct to map for easier access
	cardMap := A2ACardStruct.AsMap()

	// Extract name and description from A2A card for record metadata
	cardName := "generated-agent"
	cardDescription := "Agent generated from A2A card"
	cardVersion := defaultVersion

	if name, ok := cardMap["name"]; ok {
		if nameStr, ok := name.(string); ok {
			cardName = nameStr
		}
	}

	if description, ok := cardMap["description"]; ok {
		if descStr, ok := description.(string); ok {
			cardDescription = descStr
		}
	}

	if version, ok := cardMap["version"]; ok {
		if versionStr, ok := version.(string); ok && versionStr != "" {
			cardVersion = versionStr
		}
	}

	// Extract authors from provider organization if available
	authors := []string{"Generated by OASF SDK"}

	if provider, ok := cardMap["provider"].(map[string]any); ok {
		if org, ok := provider["organization"].(string); ok && org != "" {
			authors = []string{org}
		}
	}

	// Use current timestamp for created_at (RFC3339 format)
	// Note: For consistent test results, this could be overridden in test fixtures
	createdAt := time.Now().UTC().Format(time.RFC3339)

	// card_schema_version refers to the A2A card schema version, not the OASF schema version
	cardSchemaVersion := "v1.0.0"

	// Create A2A data structure conforming to OASF v1.0.0 A2A data schema
	// In 1.0.0, the structure is simplified to only card_data and card_schema_version
	A2AModuleData := &structpb.Struct{
		Fields: map[string]*structpb.Value{
			"card_data": {
				Kind: &structpb.Value_StructValue{StructValue: A2ACardStruct},
			},
			"card_schema_version": {
				Kind: &structpb.Value_StringValue{StringValue: cardSchemaVersion},
			},
		},
	}

	// Create the A2A module with schema-compliant data
	A2AModule := &structpb.Struct{
		Fields: map[string]*structpb.Value{
			"name": {
				Kind: &structpb.Value_StringValue{StringValue: A2AModuleName},
			},
			"data": {
				Kind: &structpb.Value_StructValue{StructValue: A2AModuleData},
			},
		},
	}

	// Create the modules list
	modulesList := &structpb.ListValue{
		Values: []*structpb.Value{
			{
				Kind: &structpb.Value_StructValue{StructValue: A2AModule},
			},
		},
	}

	// Create OASF-compliant record with all required fields
	record := &structpb.Struct{
		Fields: map[string]*structpb.Value{
			"name": {
				Kind: &structpb.Value_StringValue{StringValue: cardName},
			},
			"schema_version": {
				Kind: &structpb.Value_StringValue{StringValue: targetSchema},
			},
			"version": {
				Kind: &structpb.Value_StringValue{StringValue: cardVersion},
			},
			"description": {
				Kind: &structpb.Value_StringValue{StringValue: cardDescription},
			},
			"authors": {
				Kind: &structpb.Value_ListValue{
					ListValue: &structpb.ListValue{
						Values: func() []*structpb.Value {
							authorValues := make([]*structpb.Value, 0, len(authors))
							for _, author := range authors {
								authorValues = append(authorValues, &structpb.Value{
									Kind: &structpb.Value_StringValue{StringValue: author},
								})
							}

							return authorValues
						}(),
					},
				},
			},
			"created_at": {
				Kind: &structpb.Value_StringValue{StringValue: createdAt},
			},
			"skills": {
				Kind: &structpb.Value_ListValue{
					ListValue: &structpb.ListValue{
						Values: []*structpb.Value{},
					},
				},
			},
			"domains": {
				Kind: &structpb.Value_ListValue{
					ListValue: &structpb.ListValue{
						Values: []*structpb.Value{},
					},
				},
			},
			"modules": {
				Kind: &structpb.Value_ListValue{ListValue: modulesList},
			},
		},
	}

	return record, nil
}
